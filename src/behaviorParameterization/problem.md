A well-known problem in software engineering is that no matter what you do, 
user requirements will change. For example, imagine an application to help a farmer understand his inventory. 
The farmer might want a functionality to find all green apples in his inventory. 
But the next day he might tell you, “Actually I also want to find all apples heavier than 150 g.” 
Two days later, the farmer comes back and adds, “It would be really nice if I could find all apples that are green and heavier 
than 150 g.” How can you cope with these changing requirements? Ideally you’d like to minimize your engineering effort.
 In addition, similar new functionalities ought to be straightforward to implement and maintainable in the long term.
